@model MVC.ViewModels.Outbound.OutboundCreateVM
@{
    ViewData["Title"] = "Create Outbound";
    Layout = "~/Views/Shared/_Layout.cshtml";
}

<div class="container-fluid mt-3">
    <div class="d-flex justify-content-between align-items-center mb-3">
        <h2 class="h5 mb-0">الصادرات</h2>
        <div>
            <a class="btn btn-secondary" asp-action="Index">عودة</a>
        </div>
    </div>

    <form asp-action="Create" method="post" id="outboundForm">
        @Html.AntiForgeryToken()

        <div class="row g-3 mb-3">
            <div class="col-12 col-md-6">
                <label asp-for="ClientId" class="form-label">العميل</label>
                <select asp-for="ClientId" class="form-select" asp-items="Model.Clients">
                    <option value="">-- اختر العميل --</option>
                </select>
                <span asp-validation-for="ClientId" class="text-danger"></span>
            </div>
        </div>

        <h5 class="mt-3 mb-2">Lines</h5>
        <div class="card mb-3">
            <div class="card-body p-2 p-sm-3">
                <div class="table-responsive">
                    <table class="table table-sm table-bordered mb-0" id="linesTable">
                        <thead class="table-light">
                            <tr>
                                <th class="w-35">المنتج</th>
                                <th class="w-25 d-none d-sm-table-cell">المخزن</th>
                                <th class="w-10">الكرتون</th>
                                <th class="w-10">بالتات</th>
                                <th class="w-10">العمليات</th>
                            </tr>
                        </thead>
                        <tbody>
                            @for (int i = 0; i < Model.Details.Count; i++)
                            {
                                <tr>
                                    <td>
                                        <select name="Details[@i].ProductId" class="form-select line-input">
                                            <option value="">-- اختر المنتج --</option>
                                            @foreach (var p in Model.Products)
                                            {
                                                if (p.Value == Model.Details[i].ProductId.ToString())
                                                {
                                                    <option value="@p.Value" selected>@p.Text</option>
                                                }
                                                else
                                                {
                                                    <option value="@p.Value">@p.Text</option>
                                                }
                                            }
                                        </select>
                                    </td>
                                    <td class="d-none d-sm-table-cell">
                                        <select name="Details[@i].SectionId" class="form-select line-input">
                                            <option value="">-- اختر المخزن --</option>
                                            @foreach (var s in Model.Sections)
                                            {
                                                if (s.Value == Model.Details[i].SectionId.ToString())
                                                {
                                                    <option value="@s.Value" selected>@s.Text</option>
                                                }
                                                else
                                                {
                                                    <option value="@s.Value">@s.Text</option>
                                                }
                                            }
                                        </select>
                                    </td>
                                    <td>
                                        <input type="number" name="Details[@i].Cartons" class="form-control line-input" value="@Model.Details[i].Cartons" min="0" />
                                    </td>
                                    <td>
                                        <input type="number" name="Details[@i].Pallets" class="form-control line-input" value="@Model.Details[i].Pallets" min="0" />
                                    </td>
                                    <td class="text-center">
                                        <button type="button" class="btn btn-sm btn-danger remove-line">حذف</button>
                                    </td>
                                </tr>
                            }
                        </tbody>
                    </table>
                </div>

                <div class="mt-2 d-flex gap-2">
                    <button type="button" id="addLine" class="btn btn-sm btn-outline-secondary">إضافة سطر (أو Enter)</button>
                    <div class="text-muted small">اضغط Enter في آخر خانة لإضافة السطر التالي والانتقال إليه</div>
                </div>
            </div>
        </div>

        <div class="d-flex justify-content-between align-items-center mb-3">
            <div>
                <strong>Totals:</strong> Cartons: <span id="totalCartons">0</span> &nbsp; Pallets: <span id="totalPallets">0</span>
            </div>
            <div class="d-none d-sm-block">
                <button type="submit" class="btn btn-primary">حفظ الإذن</button>
            </div>
        </div>

        <div class="d-block d-sm-none mt-3">
            <button type="submit" class="btn btn-primary w-100">حفظ الإذن</button>
        </div>
    </form>
</div>

@section Scripts {
    <script>
        (function() {
            // initial lists serialized from server model
            const products = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(Model.Products.Select(p => new { value = p.Value, text = p.Text })));
            const sections = @Html.Raw(System.Text.Json.JsonSerializer.Serialize(Model.Sections.Select(s => new { value = s.Value, text = s.Text })));
            
            // keep immutable copies of initial lists so we can restore when client is cleared
            const initialProducts = products.map(p => ({ value: p.value, text: p.text }));
            const initialSections = sections.map(s => ({ value: s.value, text: s.text }));
            
            const clientSelect = document.querySelector('[name="ClientId"]');
            const tbody = document.querySelector('#linesTable tbody');
            
            function recalcTotals() {
                let cartons = 0, pallets = 0;
                document.querySelectorAll('#linesTable tbody tr').forEach(row => {
                    const cEl = row.querySelector('input[name$=".Cartons"]');
                    const pEl = row.querySelector('input[name$=".Pallets"]');
                    const c = cEl ? parseInt(cEl.value || '0') : 0;
                    const p = pEl ? parseInt(pEl.value || '0') : 0;
                    cartons += isNaN(c) ? 0 : c;
                    pallets += isNaN(p) ? 0 : p;
                });
                document.getElementById('totalCartons').innerText = cartons;
                document.getElementById('totalPallets').innerText = pallets;
            }
            
            function addLine() {
                const index = tbody.children.length;
                const tr = document.createElement('tr');
                tr.innerHTML = `\
                    <td>\
                        <select name="Details[${index}].ProductId" class="form-select line-input">\
//+                        <option value="">-- اختر المنتج --</option>\
+                        <option value="">-- اختر المنتج --</option>\
                            ${products.map(p => `<option value="${p.value}">${p.text}</option>`).join('')}\
                        </select>\
                    </td>\
                    <td class="d-none d-sm-table-cell">\
                        <select name="Details[${index}].SectionId" class="form-select line-input">\
                            <option value="">-- اختر المخزن --</option>\
                            ${sections.map(s => `<option value="${s.value}">${s.text}</option>`).join('')}\
                        </select>\
                    </td>\
                    <td><input type="number" name="Details[${index}].Cartons" class="form-control line-input" value="0" min="0" /></td>\
                    <td><input type="number" name="Details[${index}].Pallets" class="form-control line-input" value="0" min="0" /></td>\
                    <td class="text-center"><button type="button" class="btn btn-sm btn-danger remove-line">حذف</button></td>\
                `;
                tbody.appendChild(tr);
                attachRowEvents(tr);
                recalcTotals();
                const first = tr.querySelector('.line-input');
                if (first) first.focus();
            }
            
            function attachRowEvents(tr) {
                const inputs = Array.from(tr.querySelectorAll('.line-input'));
                inputs.forEach((inp, idx) => {
                    inp.addEventListener('input', recalcTotals);
                    inp.addEventListener('keydown', function (ev) {
                        if (ev.key === 'Enter') {
                            ev.preventDefault();
                            // When Enter pressed in a quantity field, if it's Cartons or Pallets, subtract from stock and move to next row
                            const name = inp.getAttribute('name') || '';
                            const isCarton = name.endsWith('.Cartons');
                            const isPallet = name.endsWith('.Pallets');

                            if (isCarton || isPallet) {
                                // find product & section for this row
                                const row = inp.closest('tr');
                                const prodId = row.querySelector('select[name$=".ProductId"]').value;
                                const secId = row.querySelector('select[name$=".SectionId"]').value;
                                const cartonsEl = row.querySelector('input[name$=".Cartons"]');
                                const palletsEl = row.querySelector('input[name$=".Pallets"]');
                                const cartons = parseInt(cartonsEl.value || '0');
                                const pallets = parseInt(palletsEl.value || '0');

                                if (!prodId || !secId) {
                                    alert('اختر المنتج والمخزن أولاً.');
                                    return;
                                }
-
-                                // locate stock record in stocks array
-                                const key = `${prodId}_${secId}`;
-                                const stock = stocksMap.get(key);
-
-                                if (!stock) {
-                                    alert('لا يوجد رصيد لهذا المنتج في هذا المخزن.');
-                                } else {
-                                    // subtract entered quantities from stocksMap (client-side) to reflect remaining
-                                    stock.cartons = Math.max(0, stock.cartons - cartons);
-                                    stock.pallets = Math.max(0, stock.pallets - pallets);
-
-                                    // update any rows below that reference same prod/sec by setting placeholders or adjusting available display (if implemented)
-                                }
-
-                                // Move focus to the next input in sequence (natural order)
-                                const allInputs = Array.from(document.querySelectorAll('.line-input'));
-                                const pos = allInputs.indexOf(inp);
-                                if (pos >= 0 && pos < allInputs.length - 1) {
-                                    allInputs[pos + 1].focus();
-                                } else {
-                                    addLine();
-                                }
-                                recalcTotals();
-                                return;
+                                // send AJAX to server to create or append the outbound line and update DB
+                                const tokenInput = document.querySelector('input[name="__RequestVerificationToken"]');
+                                const token = tokenInput ? tokenInput.value : null;
+                                const payload = {
+                                    clientId: parseInt(document.querySelector('[name="ClientId"]').value || '0'),
+                                    productId: parseInt(prodId || '0'),
+                                    sectionId: parseInt(secId || '0'),
+                                    cartons: cartons,
+                                    pallets: pallets
+                                };
+                                if (currentOutboundId) payload.outboundId = currentOutboundId;
+
+                                // disable row inputs to prevent double submit
+                                const rowInputs = Array.from(row.querySelectorAll('select, input'));
+                                rowInputs.forEach(el => el.disabled = true);
+
+                                fetch('/Outbound/AddLineAjax', {
+                                    method: 'POST',
+                                    headers: {
+                                        'Content-Type': 'application/json',
+                                        'RequestVerificationToken': token
+                                    },
+                                    body: JSON.stringify(payload)
+                                }).then(r => r.json())
+                                .then(resp => {
+                                    if (!resp || !resp.success) {
+                                        throw new Error((resp && resp.error) ? resp.error : 'Server error');
+                                    }
+                                    // save outbound id for subsequent lines
+                                    currentOutboundId = resp.id || currentOutboundId;
+
+                                    // update client-side stocks map as we consumed quantities
+                                    const key = `${prodId}_${secId}`;
+                                    const stock = stocksMap.get(key);
+                                    if (stock) {
+                                        stock.cartons = Math.max(0, (stock.cartons || 0) - cartons);
+                                        stock.pallets = Math.max(0, (stock.pallets || 0) - pallets);
+                                    }
+
+                                    // visually mark row saved
+                                    row.classList.add('table-success');
+                                    setTimeout(()=> row.classList.remove('table-success'), 800);
+
+                                    // move focus to next input
+                                    const allInputs = Array.from(document.querySelectorAll('.line-input'));
+                                    const pos = allInputs.indexOf(inp);
+                                    if (pos >= 0 && pos < allInputs.length - 1) {
+                                        allInputs[pos + 1].focus();
+                                    } else {
+                                        addLine();
+                                    }
+                                    recalcTotals();
+                                })
+                                .catch(err => {
+                                    alert('فشل الحفظ: ' + (err && err.message ? err.message : ''));
+                                    // re-enable row inputs on failure
+                                    rowInputs.forEach(el => el.disabled = false);
+                                });
+                                return;
                             }

                            // default behavior: move to next input in same row or add line
                            if (idx < inputs.length - 1) {
                                inputs[idx + 1].focus();
                                return;
                            }
                            addLine();
                        }
                    });
                });
+                // when product select changes, update section select in same row
+                const prodSel = tr.querySelector('select[name$=".ProductId"]');
+                if (prodSel) {
+                    prodSel.addEventListener('change', function () {
+                        const sectionSel = tr.querySelector('select[name$=".SectionId"]');
+                        if (!sectionSel) return;
+                        const allowed = getSectionsForProduct(this.value);
+                        const secOptions = `<option value="">-- اختر المخزن --</option>` + allowed.map(s => `<option value="${s.value}">${s.text}</option>`).join('');
+                        const curSec = sectionSel.value;
+                        sectionSel.innerHTML = secOptions;
+                        if (curSec && allowed.some(s => String(s.value) === String(curSec))) sectionSel.value = curSec; else sectionSel.value = '';
+                    });
+                }
            
                const btn = tr.querySelector('.remove-line');
                if (btn) btn.addEventListener('click', function() {
                    tr.remove();
                    document.querySelectorAll('#linesTable tbody tr').forEach((r,i) => {
                        r.querySelectorAll('select, input').forEach(el => {
                            const name = el.getAttribute('name');
                            if (!name) return;
                            el.setAttribute('name', name.replace(/Details\[\d+\]/, `Details[${i}]`));
                        });
                    });
                    recalcTotals();
                });
            }
            
            document.getElementById('addLine').addEventListener('click', addLine);
            
            // pairs of product-section for selected client (filled after fetch)
            let pairs = [];
            // map of product_section -> {cartons,pallets} reflecting available quantities for current client
            const stocksMap = new Map();
            // outboundId created on first Enter (used to append subsequent lines via AJAX)
            let currentOutboundId = null;
            
            // when client changes, fetch client's available products & sections then update selects
            clientSelect.addEventListener('change', function () {
                const clientId = this.value;

                function applyListsToSelects() {
                    const prodOptions = `<option value="">-- اختر المنتج --</option>` + products.map(p => `<option value="${p.value}">${p.text}</option>`).join('');

                    // update all product selects and their corresponding section selects
                    document.querySelectorAll('select[name$=".ProductId"]').forEach(sel => {
                        const cur = sel.value;
                        sel.innerHTML = prodOptions;
                        if (cur && products.some(p => String(p.value) === String(cur))) sel.value = cur; else sel.value = '';

                        // update section select in same row based on selected product
                        const row = sel.closest('tr');
                        const sectionSel = row ? row.querySelector('select[name$=".SectionId"]') : null;
                        if (sectionSel) {
                            const allowed = getSectionsForProduct(sel.value);
                            const secOptions = `<option value="">-- اختر المخزن --</option>` + allowed.map(s => `<option value="${s.value}">${s.text}</option>`).join('');
                            const curSec = sectionSel.value;
                            sectionSel.innerHTML = secOptions;
                            if (curSec && allowed.some(s => String(s.value) === String(curSec))) sectionSel.value = curSec; else sectionSel.value = '';
                        }
                    });

                    // if no rows exist, add a blank one so user can pick
                    if (tbody.children.length === 0) addLine();
                }

                if (!clientId) {
                    // restore initial lists
                    products.length = 0; initialProducts.forEach(p => products.push(p));
                    sections.length = 0; initialSections.forEach(s => sections.push(s));
                    pairs = [];
                    applyListsToSelects();
                    return;
                }

                fetch(`/Stock/GetClientStocks?clientId=${clientId}`)
                    .then(res => {
                        if (!res.ok) throw new Error('Network response was not ok');
                        return res.json();
                    })
                    .then(data => {
                        // server expected to return { products: [{value,text}], sections: [{value,text}] }
                        products.length = 0; (data.products || []).forEach(p => products.push(p));
                        sections.length = 0; (data.sections || []).forEach(s => sections.push(s));
-                        pairs = data.pairs || [];
+                        pairs = data.pairs || [];
+                        // load stocks into stocksMap for client-side depletion
+                        stocksMap.clear();
+                        (data.stocks || []).forEach(s => {
+                            const key = `${s.productId}_${s.sectionId}`;
+                            stocksMap.set(key, { cartons: s.cartons || 0, pallets: s.pallets || 0 });
+                        });
                         applyListsToSelects();
                     })
                     .catch(err => { console.error('Failed to load client stocks', err); });
             });
            
            // helper: return sections allowed for a product based on pairs and sections list
            function getSectionsForProduct(productId) {
                if (!productId) return sections;
                const allowedIds = pairs.filter(p => String(p.productId) === String(productId)).map(p => String(p.sectionId));
                return sections.filter(s => allowedIds.includes(String(s.value)));
            }
            
            // wire up existing rows (if any) and totals
            document.querySelectorAll('#linesTable tbody tr').forEach(tr => attachRowEvents(tr));
            recalcTotals();
            
            // if there's an initial selected client, trigger to load its stocks
            if (clientSelect && clientSelect.value) {
                // trigger change to fetch filtered lists
                const ev = new Event('change');
                clientSelect.dispatchEvent(ev);
            }
        })();
    </script>
}
